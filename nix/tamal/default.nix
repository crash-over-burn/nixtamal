/*
SPDX-FileCopyrightText: 2025 toastal
SPDX-License-Identifier: ISC

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice & this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED “AS IS” & ISC DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY &
FITNESS. IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
OF THIS SOFTWARE.

──────────────────────────────────────────────────────────────────────────────
┏┓╻+╻ ╱┏┳┓┏┓┏┳┓┏┓╻
┃┃┃┃┗━┓╹┃╹┣┫┃┃┃┣┫┃   This file was generated by Nixtamal.
╹┗┛╹╱ ╹ ╹ ╹╹╹ ╹╹╹┗┛  Do not edit as it will be overwritten.
──────────────────────────────────────────────────────────────────────────────
*/
{
	system ? builtins.currentSystem,
	nixpkgs ? null,
	bootstrap-nixpkgs-lock-name ? null,
}:

let lock = builtins.fromJSON (builtins.readFile ./lock.json); in
assert (lock.v == "0.1.0");
let
	try-fetch = name: fetcher:
		let
			try-fetch' = failed-urls: url: urls:
				let result = builtins.tryEval (fetcher url); in
				if result.success then
					result.value
				else
					let failed-urls' = [ url ] ++ failed-urls; in
					if builtins.length urls <= 0 then
						let fus = builtins.concatStringsSep " " failed-urls'; in
						builtins.throw "Input 「${name}」fetchable @ [ ${fus} ]"
					else
						try-fetch' failed-urls' (builtins.head urls) (builtins.tail urls);
		in
		try-fetch' [ ];

	builtin-fetch-tarball = {name, kind, hash}:
		try-fetch name (url:
			builtins.fetchTarball {
				inherit url;
				${hash.al} = hash.vl;
			}
		) kind.ur kind.ms;

	builtin-to-input = name: input:
		let k = builtins.head input.kd; in
		if k == 1 then
			builtin-fetch-tarball {
				inherit name;
				kind = builtins.elemAt input.kd 1;
				hash = input.ha;
			}
		else
			throw "Unsupported input kind “${builtins.toString k}”.";

	nixpkgs' = if builtins.isNull nixpkgs then
		builtin-to-input "nixpkgs-for-nixtamal" (
			if builtins.isString bootstrap-nixpkgs-lock-name then
				lock.i.${bootstrap-nixpkgs-lock-name}
			else
				lock.i.nixpkgs-nixtamal or lock.i.nixpkgs
		)
	else
		nixpkgs;

	pkgs = import nixpkgs' {inherit system;};

	inherit (pkgs) lib;

	fetch-zip = {name, kind, hash}: pkgs.fetchzip {
		inherit name;
		url = kind.ur;
		${hash.al} = hash.vl;
	} // lib.optionalAttrs (builtins.length kind.ms > 0) { urls = kind.ms; };

	fetch-darcs = {name, kind, hash}:
		let
			using-mirrors = kind ? ms && (builtins.length kind.ms) > 0;
			mirror-support = pkgs.fetchdarcs.__functionArgs ? "mirrors";
			reference =
				let
					type = builtins.elemAt kind.rf 0;
					value = builtins.elemAt kind.rf 1;
				in
				if type == 0 then
					let path = builtins.elemAt value 1; in
					assert (lib.hasSuffix ".txt" path);
					let
						txt-files = lib.sourceFilesBySuffices ./. [ ".txt" ];
						dir = lib.fileset.toSource {
							root = ./.;
							fileset = lib.fileset.fromSource txt-files;
						};
					in
					{context = "${dir}/${path}";}
				else if type == 1 then
					{rev = value;}
				else
					throw "Invalid Darcs reference";
		in
		lib.warnIf (using-mirrors && !mirror-support)
			"Upstream pkgs.fetchdarcs doesn’t yet support mirrors for 「${name}」"
			pkgs.fetchdarcs ({
				url = kind.rp;
				${hash.al} = hash.vl;
			} // reference // lib.optionalAttrs (using-mirrors && mirror-support){
				mirrors = kind.ms;
			});

	to-input = name: input:
		let k = builtins.head input.kd; in
		if k == 1 then
			fetch-zip {
				inherit name;
				kind = builtins.elemAt input.kd 1;
				hash = input.ha;
			}
else if k == 3 then
			fetch-darcs {
				inherit name;
				kind = builtins.elemAt input.kd 1;
				hash = input.ha;
			}
		else
			throw "Unsupported input kind “${builtins.toString k}”.";
in
builtins.mapAttrs to-input lock.i
